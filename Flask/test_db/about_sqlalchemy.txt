

1、FLask-SQLAlchemy数据库URL
数据库引擎           URL
-----------------------------------------------
MySQL               mysql://username:password@hostname/database
Postgres            postgresql://username:password@hostname/database
SQLite(Unix)        sqlite:////absolute/path/to/database
SQLite(Windows)     sqlite:///c:/absolute/path/to/database



2、最常用的SQLAlchemy列类型
类型名           Python类型              说明
-------------------------------------------------------------------------------------
Integer         int                     普通整数，一般是 32 位
SmallInteger    int                     取值范围小的整数，一般是 16 位
BigInteger      int或long               不限制精度的整数
Float           float                   浮点数
Numeric         decimal.Decimal         定点数
String          str                     变长字符串
Text            str                     变长字符串，对较长或不限长度的字符串做了优化
Unicode         unicode                 变长 Unicode 字符串
UnicodeText     unicode                 变长 Unicode 字符串，对较长或不限长度的字符串做了优化
Boolean         bool                    布尔值
Date            datetime.date           日期
Time            datetime.time           时间
DateTime        datetime.datetime       日期和时间
Interval        datetime.timedelta      时间间隔
Enum            str                     一组字符串
PickleType      任何Python对象          自动使用 Pickle 序列化
LargeBinary     str                     二进制文件


3、最常使用的SQLAlchemy列选项
选项名              说明
----------------------------------------------------------------
primary_key         如果设为 True，这列就是表的主键
unique              如果设为 True，这列不允许出现重复的值
index               如果设为 True，为这列创建索引，提升查询效率
nullable            如果设为 True，这列允许使用空值;如果设为 False，这列不允许使用空值
default             为这列定义默认值


4、常用的SQLAlchemy关系选项
选项名               说明
---------------------------------------------------------------
backref             在关系的另一个模型中添加反向引用
primaryjoin         明确指定两个模型之间使用的联结条件。只在模棱两可的关系中需要指定
lazy                指定如何加载相关记录。可选值有 select(首次访问时按需加载)、immediate(源对象加载后就加载)、joined(加载记录，但使用联结)、
                    subquery(立即加载，但使用子查询)， noload(永不加载)和 dynamic(不加载记录，但提供加载记录的查询)
uselist             如果设为 Fales，不使用列表，而使用标量值
order_by            指定关系中记录的排序方式
secondary           指定多对多关系中关系表的名字
secondaryjoin       SQLAlchemy无法自行决定时，指定多对多关系中的二级联结条件


5、常用的SQLAlchemy查询过滤器
过滤器              说明
---------------------------------------------------------------
filter()            把过滤器添加到原查询上，返回一个新查询
filter_by()         把等值过滤器添加到原查询上，返回一个新查询
limit()             使用指定的值限制原查询返回的结果数量，返回一个新查询
offset()            偏移原查询返回的结果，返回一个新查询
order_by()          根据指定条件对原查询结果进行排序，返回一个新查询
group_by()          根据指定条件对原查询结果进行分组，返回一个新查询


6、最常使用的SQLAlchemy查询执行函数
方法                 说明
---------------------------------------------------------------
all()               以列表形式返回查询的所有结果
first()             返回查询的第一个结果，如果没有结果，则返回None
first_or_404()      返回查询的第一个结果，如果没有结果，则终止请求，返回404错误响应
get()               返回指定主键对应的行，如果没有对应的行，则返回None
get_or_404()        返回指定主键对应的行，如果没找到指定的主键，则终止请求，返回404错误响应
count()             返回查询结果的数量
paginate()          返回一个Paginate对象，它包含指定范围内的结果


7、数据库操作
进入shell：
python hello.py shell
from hello import db

（删除旧表）创建数据库表：
db.drop_all()
db.create_all()

插入行：
from hello import Role, User
admin_role = Role(name='Admin')
mod_role = Role(name='Moderator')
user_role = Role(name='User')
user_john = User(username='john', role=admin_role)
user_susan = User(username='susan', role=user_role)
user_david = User(username='david', role=user_role)

db.session.add(admin_role)
db.session.add(mod_role)
db.session.add(user_role)
db.session.add(user_john)
db.session.add(user_susan)
db.session.add(user_david)
或： db.session.add_all([admin_role, mod_role, user_role, user_john, user_susan, user_david])
db.session.commit()


修改行：
admin_role.name = 'Administrator'
db.session.add(admin_role)
db.session.commit()

删除行：
db.session.delete(mod_role)
db.session.commit()


查询行：
Role.query.all()  #查询所有记录
User.query.all()

#使用过滤器（多个过滤器可以一起调用）
User.query.filter_by(role=user_role).all()  #查找角色为"User"的所有用户

str(User.query.filter_by(role=user_role))  #查看SQLAlchemy为查询生成的原生SQL查询语句








